#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  none)
#pragma config(Sensor, S2,     ,               sensorLightActive)
#pragma config(Sensor, S3,     ,               sensorLightActive)
#pragma config(Sensor, S4,     IR,             sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  mtr_S1_C1_1,     liftb,         tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     liftt,         tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     rightt,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     rightb,        tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     leftt,         tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_2,     leftb,         tmotorTetrix, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


//here are my function prototypes
//movement allows you to move both left and right wheel a certain amount of encoder counts
//tempstop stops the robot's movement
//movestraight allows you to move the robot "perfectly" straight, by correcting for left & right drift
//centerBot is the key function of the entire program, helping to align the robot with the IR Beacon's position

void movement(int a, int b, int movementspeed = 100);
void tempstop();
void movestraight(int c, int movementspeed = 100);
void centerBot();
void lowerpeg();
void upperpeg();
void middlepeg();


task main()
{
	const int rev = 1440; //one revolution is 1440 encoder counts
	const int lightthreshold = 30; //a white tape registers above the 30% threshold returned by the lightsensor

	//SENSING PROCEDURE**************************************************************************************

	//determines whether the IR beacon is on the left, middle, or right column peg

	//start off by moving forward slightly, to a position where the
	//initial sensing operation can begin
	movestraight(1.45*rev);
	tempstop();

	//reset encoder values to 0
	nMotorEncoder[leftb] = 0;
	nMotorEncoder[rightb] =0;
	int n=0;

	//Because of our initial position, we know that the IR beacon will always be somewhere
	//in front of the robot, within the giant "5" return sector of the IR sensor.
	//While the IR sensor still detects a "5" value for the location of the beacon,
	//we will move the left motors forward, and stop as soon as the IR sensor no long returns "5".


	while (SensorValue[S4] ==5)
	{
		motor[leftb] = motor[leftt] = 20;
		motor[rightb] = motor[rightt] = 0;
	}
	motor[leftb] = motor[leftt] = motor[rightb] = motor[rightt] = 0;


	//How much the left wheels moved before the IR beacon moves out of the "5" sector of the sensor
	//is a much more accurate way to consistently determine where the peg is - in the middle, left or right columns.

	//With repeated testing, we determined that the left wheels move anywhere between 603 to 884 encoder counts if the
	//IR beacon is in the left column, between 1300-1550 encoder counts if the IR beacon is in the middle column, and
	//between 1900 and 2100 encoder counts if the beacon is in the right column.
	//With these values already pre-researched, we can compare them to how much left wheels just moved right now (stored in variable "n")
	//to determine where the robot should move
	n = abs(nMotorEncoder[leftb]);

    //Ssometimes, the sensing procedure won't work properly if the robot is angled wrong initially.
    //The most common error is that the IR beacon is in the right column, and the IR sensor returns sector "6", initially.
    //If this happens, the left motors won't move at all, because they rely on the IR sensorvalue of 5.

    //To account for this, I made the following "if" statement - if the left motors didn't move at all really, & the IR Sensor
    //returns 6 or higher, I will manually assign "n" to 2200, thus telling the program to move into the
    //"right column of pegs" block of code
	if (n < 100 && SensorValue[S4] >5)
	{
		n = 2200;
	}

	//I accounted for the same possibility if the IR Sensor returned sector 4 or lower, explicitly telling the program
	//to enter the left column section of code
	else if (n <100 && SensorValue[S4] <5)
	{
		n = 100;
	}

	//If somehow, the robot doesn't move, even though the Beacon is in the 5 sector, I will explicitly tell the program to
	//enter the middle column section of code
	else if (n < 100 && SensorValue[S4] == 5)
	{
		n = 1300;
	}





	//MOVING PROCEDURE**************************************************************************************

	//moves robot to appropriate position based on where the beacon is by comparing "n" to previously researched known values


	if (n < 1200)//if the beacon is on the left peg...
	{
		//move the left wheels back from the sensing procedure location
		while (nMotorEncoder[leftb] > 0)
		{
			motor[leftb] = motor[leftt] = -30;
			motor[rightb] = motor[rightt] = 0;
		}
		tempstop();

		//make appropriate turns to position robot as close to the left column of pegs as possible
		movestraight(1.3*rev);
		tempstop();
		movement(0, 2.5*rev);
		tempstop();
		movestraight(.65*rev);
		tempstop();
		movement(2.4*rev, 0);
		tempstop();
		movestraight(.55 * rev);
		tempstop();

		//angle the robot so that its claw is "perfectly" aligned to the peg
		//originally, the "centerBot" function was called here, but we decided to explicitly re-write it's content
		//into task main (its the code you see below) because the "constant ratio" that we use to center with
		//differed slightly between the the left, and right column pegs

		//set the encoder values to 0
		nMotorEncoder[leftb] = 0;
		nMotorEncoder[rightb] = 0;

		//we assume that the IR beacon is somewhere within the 5 sector to begin with (a valid assumption, since
		//the purpose of the turns we made previously was to position the robot right in front of the left column of pegs)
		//And we will move the robot until it is on the 4-5 sectors' boundary
		while (SensorValue[S4] == 5)
		{
			motor[leftb] = motor[leftt] = 20;
			motor[rightb] = motor[rightt] = 0;
		}//robot is between 4 and 5 sectors
		motor[leftt] = motor[rightt] = motor[rightb] = motor[leftb] = 0;


		//we'll reset the encoder values to 0, so that the distance it now travels in the next while statement
		//is the distance the left wheels have to travel to get between the 4-5 boundary and the 5-6 boundary
		nMotorEncoder[leftb] = 0;
		nMotorEncoder[rightb] = 0;
		while (SensorValue[S4] !=6)//this while loop will move the left wheels until the robot sees the IR sensor in the 5-6 boundary
		{
			motor[leftb] = motor[leftt] = -20;
			motor[rightb] = motor[rightt] = 0;
		}
		motor[leftt] = motor[rightt] = motor[rightb] = motor[leftb] = 0;

		//About 18% of the way that the left wheels traveled (determined by trial and error) should be where
		//the IR beacon is, and we store that value in the floating point value "h"
		float n = abs(nMotorEncoder[leftb])*.18;

		//we reset the encoders to 0, yet again...
		nMotorEncoder[leftb] = 0;
		nMotorEncoder[rightb] = 0;

		//and move the robot's left wheel until it has reached the magical target to align with the IR beacon
		while (abs(nMotorEncoder[leftb]) < n)
		{
			motor[leftb] = motor[leftt] = 20;
			motor[rightb] = motor[rightt] = 0;
		}
		tempstop();

		//lift the arm so that the ring is at the appropriate height
		lowerpeg();
		/*motor[liftb] = motor[liftt] = 25;
		wait1Msec(235);*/


		//and voila! move the robot forward, so that the ring goes perfectly into the peg!
		movestraight(1.5*rev);


		//lower the arm, and bring the robot back out of everybody else's way
		motor[liftb] = motor[liftt] = -4;
		wait1Msec(50);
		motor[leftt] = motor[rightt] = motor[rightb] = motor[leftb] = -15;
		wait1Msec(2000);
		motor[liftb] = motor[liftt] = -25;
		wait1Msec(750);
		motor[liftt] = motor[liftb] = 0;

		//now, move the robot back towards the ring dispensers to prepare for the driver period
		movement(0,1.7*rev);
		tempstop();
		movestraight(.2*rev,10);
		tempstop();
		movement(0,1.8*rev);
		tempstop();


	}


	else if (n < 1700 && n >= 1200)//otherwise, if the beacon is on the middle column
	{
		//reset the encoder to 0. The robot is currently on the 4-5 sector border, following the finishing of the sensing procedure
		nMotorEncoder[leftb] = 0;

		//we will move the robot backwards until it is along the 5-6 sector border
		while (SensorValue[S4] != 6)
		{
			motor[leftt] = motor[leftb] = -20;
		}
		motor[leftt] = motor[leftb] = 0;


		//To align the robot with the IR beacon, the robot will move forward, approximately 10% the distance between
		//the border of the 4-5 sector, and the border of the 5-6 sector, aligning it with the IR beacon.
		//This 1/10 ratio of the total distance between the borders of sector 5 was determined by repeated
		//trial and error to determine a constant that would consistently align the robot with the beacon.
		float z = abs(nMotorEncoder[leftb])*.10;
		nMotorEncoder[leftb] = 0;
		while (abs(nMotorEncoder[leftb]) < z)
		{
			motor[leftt] = motor[leftb] = 20;
		}
		tempstop();

		//Now the robot will move forward, past the bump, and will stop temporarily
		movement(1.2*rev,1.25*rev);
        tempstop();
		movestraight(2.38*rev);
		tempstop();
		motor[leftt] = motor[leftb] = motor[rightb] = motor[rightt] = 0;

		//because the physics of the robot's motion in getting past the bump will change throughout various autonomous
		//periods, we will realign the robot with the middle column of pegs by moving the right wheels until the light sensor "sees"
		//the white line. It will follow the white line until the left wheels have turned about 1/3 of a revolution

		nMotorEncoder[leftb] = 0;
		nMotorEncoder[rightb] = 0;

		while (abs(nMotorEncoder[leftb]) < (.32*rev))
		{
			if (SensorValue[S3] < lightthreshold)
			{
				motor[leftt] = motor[leftb] = 0;
				motor[rightb] = 60;
				motor[rightt] = 60;
			}
			else
			{
				motor[leftt] = 50;
				motor[leftb] = 50;
				motor[rightb] = motor[rightt] = 0;

			}

		}
		tempstop();

		//now we lift the arm holding the ring to the appropriate height...
		lowerpeg();

		//and we continue following the white line for 1.5 revolutions, shimmying the robot, as well as the autonomous
		//ring it's carrying into the peg
		nMotorEncoder[leftb] = 0;
		nMotorEncoder[rightb] = 0;

		while (abs(nMotorEncoder[leftb]) < (1.5*rev))
		{
			if (SensorValue[S3] < lightthreshold)
			{
				motor[leftt] = motor[leftb] = 0;
				motor[rightb] = 60;
				motor[rightt] = 60;
			}
			else
			{
				motor[leftt] = 50;
				motor[leftb] = 50;
				motor[rightb] = motor[rightt] = 0;

			}

		}
		tempstop();

		//now we back away & lower the lift
		motor[liftb] = motor[liftt] = -20;
		wait1Msec(100);
		motor[leftt] = motor[rightt] = motor[rightb] = motor[leftb] = -25;
		wait1Msec(3000);
		motor[liftb] = motor[liftt] = -25;
		wait1Msec(250);
		motor[leftt] = motor[rightt] = motor[rightb] = motor[leftb] = 0;
		motor[liftb] = motor[liftt] = 0;

        //Finally, we move the robot so that its right in front of the ring dispenser, preparing us
        //for the driver period
		movement(-1.5*rev,-1.5*rev);
		tempstop();
		movement(0,1.3*rev);
		tempstop();
		movestraight(1.5*rev);
		tempstop();
		movement(0,2.1*rev):
		tempstop();
	}


	else if (n >= 1600)//finally, otherwise if the beacon was located on the right column of pegs...
	{
		//move the left wheels back from the sensing procedure location
		//this if statement  allows this to execute only if the sensing mechanism did
		//move the left wheels (thus causing the IR sensor to return "4", and causing the condition in the "if" to be true)
		//but, if the left wheels didn't move at all, and "n" was explicitly assigned a value to bring it into this code section
		//the while loop won't execute
		if (SensorValue[S4] != 6)
		{
			while (nMotorEncoder[leftb] > 0)
			{
				motor[leftb] = motor[leftt] = -30;
				motor[rightb] = motor[rightt] = 0;
			}
			tempstop();
		}
		tempstop();

		//make appropriate turns to position robot as close to the right column of pegs as possible
		movestraight(1.3*rev);
		tempstop();
		movement(2*rev, 0);
		tempstop();
		movestraight(.55*rev);
		tempstop();
		movement(0,2.3*rev);
		tempstop();
		movestraight(0.8*rev, 50);


		//angle the robot so that its claw is "perfectly" aligned to the peg
		centerBot();
		tempstop();

        //here, we explicitly wrote the content of the function "lowerpeg" for debugging purposes, so that
        //we could change the values of how high the arm lifted within this branch of code
        //basically, the arm will now lift to the height of the lowerpeg using the pre-determined encoder count value
        //of 73. This value was determined through trial and error.

		nMotorEncoder[liftb] = 0;
		nMotorEncoder[liftt] =0;
		while (abs(nMotorEncoder[liftb]) < 73 || abs(nMotorEncoder[liftt]) < 73)
		{
			if (nMotorEncoder[liftb] == nMotorEncoder[liftt])
				motor[liftb] = motor[liftt] = 20;
			else if (abs(nMotorEncoder[liftb]) < abs(nMotorEncoder[liftt]))
			{
				motor[liftb] = 20;
				motor[liftt] = 20* .75;
			}
			else if (abs(nMotorEncoder[liftb]) > abs(nMotorEncoder[liftt]))
			{
				motor[liftb] = 20*.75;
				motor[liftt] = 20;
			}
		}
		motor[liftt] = motor[liftb] = 0;

		tempstop();

		/*motor[liftb] = motor[liftt] = 25;
		wait1Msec(235);*/


		//and voila! move the robot forward, so that the ring goes perfectly into the peg!
		movestraight(1.3*rev);

		//lower the arm, and bring the robot back
		motor[liftb] = motor[liftt] = -4;
		wait1Msec(50);
		motor[leftt] = motor[rightt] = motor[rightb] = motor[leftb] = -25;
		wait1Msec(1000);
		motor[liftb] = motor[liftt] = -25;
		wait1Msec(750);
		motor[liftt] = motor[liftb] = 0;

        //now we move the robot to the ring dispenser, to prepare for our driver period
		movement(-1.4*rev,0);
		movement(0,1.7*rev);
		tempstop();
		movestraight(1*rev);
		tempstop();
		movement(2*rev,0);
		tempstop();
		movestraight(3.6*rev);
		tempstop();
		movement(0,2*rev);
		tempstop();
	}

}


//here's our encoder-using movement function - takes up to 3 arguments (2 required)
//first argument = target encoder value for left wheel movement
//second argument = target encoder value for right wheel movement
//third optional argument = movementspeed, supplied as 100% for default

/*
  Note: We use absolute values so that the commands are as explicit as possible.
  At one point the robot was wired wrong, causing the encoder to return negative values
  when the wheels were actually moving forward, forcing us to use the absolute values, but
  now that issue is resolved. We are still using the absolute values even if they are now redundant
  and inefficient, because they help define the function more explicitly
*/

void movement(int a, int b, int movementspeed)
{
	//reset current encoders to 0 before any movement begins

	nMotorEncoder[leftb] = 0;
	nMotorEncoder[rightb] = 0;

	if (a <= 0 && b <= 0)//if both target for left & right wheels are negative...
	{
		while (abs(nMotorEncoder[leftb]) < abs(a) || abs(nMotorEncoder[rightb]) < abs(b))//while either left or right wheels haven't reached target
		{
			if (abs(nMotorEncoder[leftb]) < abs(a) && abs(nMotorEncoder[rightb]) < abs(b))//if both wheels haven't reached target, move both backwards
			{
				motor[leftt] = motor[leftb] = motor[rightt] = motor[rightb] = - movementspeed;

			}
			else if (abs(nMotorEncoder[leftb]) < abs(a) && abs(nMotorEncoder[rightb]) >= abs(b))// if left wheel hasn't reached target, but right has, move only the left
			{
				motor[leftt] = motor[leftb] = -movementspeed;
				motor[rightt] = motor[rightb] = 0;
			}
			else if (abs(nMotorEncoder[leftb]) >= abs(a) && abs(nMotorEncoder[rightb]) < abs(b))// if left wheel has reached target, but right hasn't, move only the right
			{
				motor[leftt] = motor[leftb] = 0;
				motor[rightt] = motor[rightb] = -movementspeed;
			}
			else if (abs(nMotorEncoder[leftb]) >= abs(a) && abs(nMotorEncoder[rightb]) >= abs(b))// if left wheel & right wheel have reached targets, don't move, and exit function
			{
				motor[leftt] = motor[leftb] = 0;
				motor[rightt] = motor[rightb] = 0;
				return;
			}
		}
		return;//catch-all return for good programming practice
	}//end 1st "if" block


	if (a <= 0 && b >= 0)//if target for left is negative and right is positive
	{
		while (abs(nMotorEncoder[leftb]) < abs(a) || abs(nMotorEncoder[rightb]) < abs(b))//while either left or right wheels haven't reached target
		{
			if (abs(nMotorEncoder[leftb]) < abs(a) && abs(nMotorEncoder[rightb]) < abs(b))//if both wheels haven't reached target move both towards target
			{
				motor[leftt] = motor[leftb] = -movementspeed;
				motor[rightt] = motor[leftt] = movementspeed;
			}
			else if (abs(nMotorEncoder[leftb]) < abs(a) && abs(nMotorEncoder[rightb]) >= abs(b))//if left wheel hasn't reached target, but right wheel has, move only left wheel
			{
				motor[leftt] = motor[leftb] = -movementspeed;
				motor[rightt] = motor[rightb] = 0;
			}
			else if (abs(nMotorEncoder[leftb]) >= abs(a) && abs(nMotorEncoder[rightb]) < abs(b))//if left wheel has reached target, but right wheel hasn't, move only right wheel
			{
				motor[leftt] = motor[leftb] =0;
				motor[rightt] = motor[rightb] = movementspeed;
			}
			else if (abs(nMotorEncoder[leftb]) >= abs(a) && abs(nMotorEncoder[rightb]) >= abs(b))// if left wheel & right wheel have reached targets, don't move, and exit function
			{
				motor[leftt] = motor[leftb] = 0;
				motor[rightt] = motor[rightb] = 0;
				return;
			}
		}
		return;
	}


	if (a >= 0 && b <= 0)//if target for left is positive and right is negative
	{
		while (abs(nMotorEncoder[leftb]) < abs(a) || abs(nMotorEncoder[rightb]) < abs(b))//while either left or right wheels haven't reached target
		{
			if (abs(nMotorEncoder[leftb]) < abs(a) && abs(nMotorEncoder[rightb]) < abs(b))//if both wheels haven't reached target, move both backwards
			{
				motor[leftt] = motor[leftb] = movementspeed;
				motor[rightt] = motor[rightb] = -movementspeed;
			}
			else if (abs(nMotorEncoder[leftb]) < abs(a) && abs(nMotorEncoder[rightb]) >= abs(b))//if left wheel hasn't reached target, but right has, move only left
			{
				motor[rightt] = motor[rightb] = 0;
				motor[leftb] = motor[leftt] = movementspeed;
			}
			else if (abs(nMotorEncoder[leftb]) >= abs(a) && abs(nMotorEncoder[rightb]) < abs(b))//if left wheel has reached target, but right wheel hasn't, move only right wheel
			{
				motor[leftt] = motor[leftb] =0;
				motor[rightt] = motor[rightb] = -movementspeed;
			}
			else if (abs(nMotorEncoder[leftb]) >= abs(a) && abs(nMotorEncoder[rightb]) >= abs(b))// if left wheel & right wheel have reached targets, don't move, and exit function
			{
				motor[leftt] = motor[leftb] = 0;
				motor[rightt] = motor[rightb] = 0;
				return;
			}

		}
		return;
	}




	if (a >= 0 && b >= 0)//if target for left and right are both positive
	{
		while (abs(nMotorEncoder[leftb]) < abs(a) || abs(nMotorEncoder[rightb]) < abs(b))//while either left or right wheels haven't reached target
		{
			if (abs(nMotorEncoder[leftb]) < abs(a) && abs(nMotorEncoder[rightb]) < abs(b))//if both wheels haven't reached target, move both backwards
			{
				motor[leftt] = motor[leftb] = motor[rightt] = motor[rightb] = movementspeed;
			}
			else if (abs(nMotorEncoder[leftb]) < abs(a) && abs(nMotorEncoder[rightb]) >= abs(b))//if left wheel hasn't reached target, but right has, move only left
			{
				motor[rightt] = motor[rightb] = 0;
				motor[leftb] = motor[leftt] = movementspeed;
			}
			else if (abs(nMotorEncoder[leftb]) >= abs(a) && abs(nMotorEncoder[rightb]) < abs(b))//if left wheel has reached target, but right wheel hasn't, move only right wheel
			{
				motor[leftt] = motor[leftb] =0;
				motor[rightt] = motor[rightb] = movementspeed;
			}
			else if (abs(nMotorEncoder[leftb]) >= abs(a) && abs(nMotorEncoder[rightb]) >= abs(b))// if left wheel & right wheel have reached targets, don't move, and exit function
			{
				motor[leftt] = motor[leftb] = 0;
				motor[rightt] = motor[rightb] = 0;
				return;
			}
		}
		return;
	}

}

//a stop function designed to stop all motors for a brief period of time
//designed to be used after the previous movement function, as a crude way to stop forward momentum of robot after target is reached
void tempstop()
{
	motor[leftt] = 0;
	motor[rightt] = 0;
	motor[rightb] = 0;
	motor[leftb] = 0;
	wait1Msec(125);
}


//movestraight allows the robot to move straight for a given amount of encoder counts "c" (passed in by argument)
void movestraight(int c, int movementspeed)
{
	//first, initalize the encoders to 0
	nMotorEncoder[leftb] = 0;
	nMotorEncoder[rightb] = 0;

	//while either wheel hasn't reached target
	while (abs(nMotorEncoder[leftb]) < c || abs(nMotorEncoder[rightb]) < c)
	{
		//if both left & right wheels have traveled the same distance so far, move the wheels on both sides at same speed
		if (nMotorEncoder[leftb] == nMotorEncoder[rightb])
			motor[leftb] = motor[rightb] = motor[leftt] = motor[rightt] = movementspeed;
		//otherwise, if the left wheel has traveled less than the right wheel, move the right wheel more slowly (so that the left will catch up)
		else if (abs(nMotorEncoder[leftb]) < abs(nMotorEncoder[rightb]))
		{
			motor[leftb] = motor[leftt] = movementspeed;
			motor[rightb] = motor[rightt] = movementspeed * .75;
		}
		//otherwise, if the right wheel has traveled less than the left wheel, move the left wheel more slowly (so that the right will catch up)
		else if (abs(nMotorEncoder[leftb]) > abs(nMotorEncoder[rightb]))
		{
			motor[leftb] = motor[leftt] = movementspeed  * .75;
			motor[rightb] = motor[rightt] = movementspeed;
		}
	}
}

//here is the awesomest function ever!!! it centers the robot, aligning it with the IR beacon's signal
//The premise is that, if the IR beacon is somewhere within the 5 sector, I can move the robot's left wheels
//forward, until the beacon is in the 4-5 boundary. At that point, I can set the encoders for the left wheels to 0,
//and move the robot's left wheels backward, until it hits the 5-6 boundary. This way, the encoder value should be equal
//to the distance between the left and right boundaries of the entire "5" sector. After knowing this distance, I can
//tell the robot to move forward by a certain proportion of this distance (theoretically halfway), so that it is perfectly lined
//up with the actual IR beacon. With trial and error, we determined this porporation to be more around .23 of the distance, not .5.
//The reason why is because the IR Sensor location in our robot isn't in the center of our robot, and more towards the left.

void centerBot()
{
	//set the encoder values to 0
	nMotorEncoder[leftb] = 0;
	nMotorEncoder[rightb] = 0;

	//we assume that the IR beacon is somewhere within the 5 sector to begin with, and we will move the robot until
	//it is on the 4-5 sectors' boundary
	while (SensorValue[S4] == 5)
	{
		motor[leftb] = motor[leftt] = 20;
		motor[rightb] = motor[rightt] = 0;
	}//robot is between 4 and 5 sectors
	motor[leftt] = motor[rightt] = motor[rightb] = motor[leftb] = 0;


	//we'll reset the encoder values to 0, so that the distance it now travels in the next while statement
	//is the distance the left wheels have to travel to get between the 4-5 boundary and the 5-6 boundary
	nMotorEncoder[leftb] = 0;
	nMotorEncoder[rightb] = 0;
	while (SensorValue[S4] !=6)//this while loop will move the left wheels until the robot sees the IR sensor in the 5-6 boundary
	{
		motor[leftb] = motor[leftt] = -20;
		motor[rightb] = motor[rightt] = 0;
	}
	motor[leftt] = motor[rightt] = motor[rightb] = motor[leftb] = 0;

	//About 23.5% of the way that the left wheels traveled (determined by trial and error) should be where
	//the IR beacon is, and we store that value in the floating point value "n"
	float n = abs(nMotorEncoder[leftb])*.235;

	//we reset the encoders to 0, yet again...
	nMotorEncoder[leftb] = 0;
	nMotorEncoder[rightb] = 0;

	//and move the robot's left wheel until it has reached the magical target to align with the IR beacon
	while (abs(nMotorEncoder[leftb]) < n)
	{
		motor[leftb] = motor[leftt] = 20;
		motor[rightb] = motor[rightt] = 0;
	}
	return;
}

//Here are all of our peg functions, the ones that lift the arm to a specific height, corresponding to the height
//of a particular peg. All of the encoder count values that correspond to these heights were obtained through repeated
//trial and error

//moves the arm to the lower peg height
void lowerpeg()
{
    //we set both lift encoder values to 0, because at the start of autonomous, the arm is fully lowered
	nMotorEncoder[liftb] = 0;
	nMotorEncoder[liftt] =0;

	//while either of the two encoders hasn't reached the target of 73 counts,
	while (abs(nMotorEncoder[liftb]) < 73 || abs(nMotorEncoder[liftt]) < 73)
	{
		if (nMotorEncoder[liftb] == nMotorEncoder[liftt]) //if the encoder counts of both the top & bottom lift encoders are equal,
			motor[liftb] = motor[liftt] = 10; //move them both at the same power (10 in this case)
		else if (abs(nMotorEncoder[liftb]) < abs(nMotorEncoder[liftt]))//otherwise, if the encoder count of the bottom is less than the top
		{
			motor[liftb] = 10;  //move the top slower than the bottom
			motor[liftt] = 10* .75;
		}
		else if (abs(nMotorEncoder[liftb]) > abs(nMotorEncoder[liftt]))//if the bottom has moved more than the top,
		{
			motor[liftb] = 10*.75;//move the bottom at the slower speed
			motor[liftt] = 10;
		}
	}
	motor[liftt] = motor[liftb] = 0; //after the height has been reached, the lifting motors will stop moving
}

//moves the arm to the middle peg height
void middlepeg()
{
    //we set both lift encoder values to 0, because at the start of autonomous, the arm is fully lowered
	nMotorEncoder[liftb] = 0;
	nMotorEncoder[liftt] =0;

	//while either of the two encoders hasn't reached the target of 430 counts,
	while (abs(nMotorEncoder[liftb]) < 430 || abs(nMotorEncoder[liftt]) < 430)
	{
		if (nMotorEncoder[liftb] == nMotorEncoder[liftt])//if the encoder counts of both the top & bottom lift encoders are equal,
			motor[liftb] = motor[liftt] = 20; //move them both at the same power (20 in this case)
		else if (abs(nMotorEncoder[liftb]) < abs(nMotorEncoder[liftt]))//otherwise, if the encoder count of the bottom is less than the top
		{
			motor[liftb] = 20;  //move the top slower than the bottom
			motor[liftt] = 20* .75;
		}
		else if (abs(nMotorEncoder[liftb]) > abs(nMotorEncoder[liftt]))//if the bottom has moved more than the top,
		{
			motor[liftb] = 20*.75;//move the bottom at the slower speed
			motor[liftt] = 20;
		}
	}
	motor[liftt] = motor[liftb] = 0;//after the height has been reached, the lifting motors will stop moving
}

//moves the arm to the upper peg height
void upperpeg()
{
     //we set both lift encoder values to 0, because at the start of autonomous, the arm is fully lowered
	nMotorEncoder[liftb] = 0;
	nMotorEncoder[liftt] =0;

	//while either of the two encoders hasn't reached the target of 870 counts,
	while (abs(nMotorEncoder[liftb]) < 870 || abs(nMotorEncoder[liftt]) < 870)
	{
		if (nMotorEncoder[liftb] == nMotorEncoder[liftt])//if the encoder counts of both the top & bottom lift encoders are equal,
			motor[liftb] = motor[liftt] = 10;//move them both at the same power (10 in this case)
		else if (abs(nMotorEncoder[liftb]) < abs(nMotorEncoder[liftt]))//otherwise, if the encoder count of the bottom is less than the top
		{
			motor[liftb] = 10;  //move the top slower than the bottom
			motor[liftt] = 10* .75;
		}
		else if (abs(nMotorEncoder[liftb]) > abs(nMotorEncoder[liftt]))//if the bottom has moved more than the top,
		{
			motor[liftb] = 10*.75;  //move the bottom at the slower speed
			motor[liftt] = 10;
		}
	}
	motor[liftt] = motor[liftb] = 0;//after the height has been reached, the lifting motors will stop moving
}
